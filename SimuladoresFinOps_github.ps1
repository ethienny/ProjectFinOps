<#
.SYNOPSIS
Simulador FinOps Avançado v4.0 - Geração Completa de Dados de Custos, Métricas e Recomendações
.DESCRIPTION
Ferramenta robusta para simulação de dados FinOps incluindo:
- Custos detalhados por recurso e subscription
- Métricas de performance realísticas
- Recomendações inteligentes de otimização
- Suporte a múltiplos serviços Azure
- Análise de tendências e alertas
- Exportação em múltiplos formatos

.PARAMETER MonthsBack
Número de meses históricos para simular (padrão: 6)

.PARAMETER SimulationMode
Modo de operação: $true para simulação, $false para dados reais do Azure

.PARAMETER OutputFolder
Pasta de destino para arquivos gerados

.PARAMETER SubscriptionCount
Número de subscriptions a simular (modo simulação)

.PARAMETER ResourceDensity
Densidade de recursos por subscription: Low, Medium, High

.PARAMETER IncludeRecommendations
Incluir geração de recomendações de otimização

.PARAMETER ExportFormat
Formato de exportação: CSV, JSON, Excel

.PARAMETER LogLevel
Nível de logging: Debug, Info, Warning, Error

.EXAMPLE
.\SimuladoresFinOps_v4.ps1 -MonthsBack 12 -ResourceDensity High -ExportFormat Excel

.EXAMPLE
.\SimuladoresFinOps_v4.ps1 -SimulationMode $false -SubscriptionCount 0 -LogLevel Debug
#>

[CmdletBinding()]
param(
    [Parameter(Mandatory=$false)]
    [ValidateRange(1, 36)]
    [int]$MonthsBack = 3,
    
    [Parameter(Mandatory=$false)]
    [bool]$SimulationMode = $true,
    
    [Parameter(Mandatory=$false)]
    [ValidateScript({Test-Path $_ -IsValid})]
    [string]$OutputFolder = "C:\Users\NotTh\OneDrive\Documentos\Pessoal\PowerShell_Scripts\ProjetoFinOps\Simuladores\AutoGenerated\Output",
    
    [Parameter(Mandatory=$false)]
    [ValidateRange(1, 100)]
    [int]$SubscriptionCount = 10,
    
    [Parameter(Mandatory=$false)]
    [ValidateSet("Low", "Medium", "High")]
    [string]$ResourceDensity = "Medium",
    
    [Parameter(Mandatory=$false)]
    [bool]$IncludeRecommendations = $true,
    
    [Parameter(Mandatory=$false)]
    [ValidateSet("CSV", "JSON", "Excel")]
    [string]$ExportFormat = "CSV",
    
    [Parameter(Mandatory=$false)]
    [ValidateSet("Debug", "Info", "Warning", "Error")]
    [string]$LogLevel = "Info"
)

#region Enhanced Tag Configuration

# Configuração expandida de tags para classificação por ambiente e negócio
$script:TagConfiguration = @{
    
    # Ambientes disponíveis com probabilidades de distribuição
    Environments = @{
        'Production' = @{
            Weight = 40        # 40% dos recursos
            Code = 'prd'
            CriticalityLevel = 'High'
            BackupPolicy = 'Daily'
            MonitoringLevel = 'Enhanced'
        }
        'Staging' = @{
            Weight = 15        # 15% dos recursos  
            Code = 'stg'
            CriticalityLevel = 'Medium'
            BackupPolicy = 'Weekly'
            MonitoringLevel = 'Standard'
        }
        'Development' = @{
            Weight = 25        # 25% dos recursos
            Code = 'dev'
            CriticalityLevel = 'Low'
            BackupPolicy = 'None'
            MonitoringLevel = 'Basic'
        }
        'Testing' = @{
            Weight = 10        # 10% dos recursos
            Code = 'tst'
            CriticalityLevel = 'Low'
            BackupPolicy = 'None'
            MonitoringLevel = 'Basic'
        }
        'Sandbox' = @{
            Weight = 5         # 5% dos recursos
            Code = 'sbx'
            CriticalityLevel = 'Low'
            BackupPolicy = 'None'
            MonitoringLevel = 'Minimal'
        }
        'DR' = @{
            Weight = 5         # 5% dos recursos (Disaster Recovery)
            Code = 'dr'
            CriticalityLevel = 'High'
            BackupPolicy = 'Realtime'
            MonitoringLevel = 'Enhanced'
        }
    }
    
    # Tipos de negócio com suas características
    BusinessTypes = @{
        'ECommerce' = @{
            Weight = 20
            Code = 'ecom'
            Department = 'Digital'
            DataClassification = 'Confidential'
            ComplianceRequirement = 'PCI-DSS'
            CostCenter = 'CC-2001'
            BusinessUnit = 'Sales'
        }
        'FinancialServices' = @{
            Weight = 15
            Code = 'fin'
            Department = 'Finance'
            DataClassification = 'Restricted'
            ComplianceRequirement = 'SOX,LGPD'
            CostCenter = 'CC-3001'
            BusinessUnit = 'Finance'
        }
        'Healthcare' = @{
            Weight = 10
            Code = 'hlt'
            Department = 'Clinical'
            DataClassification = 'Restricted'
            ComplianceRequirement = 'HIPAA,LGPD'
            CostCenter = 'CC-4001'
            BusinessUnit = 'Healthcare'
        }
        'Education' = @{
            Weight = 12
            Code = 'edu'
            Department = 'Academic'
            DataClassification = 'Internal'
            ComplianceRequirement = 'LGPD'
            CostCenter = 'CC-5001'
            BusinessUnit = 'Education'
        }
        'Manufacturing' = @{
            Weight = 15
            Code = 'mfg'
            Department = 'Operations'
            DataClassification = 'Internal'
            ComplianceRequirement = 'ISO27001'
            CostCenter = 'CC-6001'
            BusinessUnit = 'Manufacturing'
        }
        'Logistics' = @{
            Weight = 10
            Code = 'log'
            Department = 'Supply Chain'
            DataClassification = 'Internal'
            ComplianceRequirement = 'LGPD'
            CostCenter = 'CC-7001'
            BusinessUnit = 'Logistics'
        }
        'Media' = @{
            Weight = 8
            Code = 'med'
            Department = 'Content'
            DataClassification = 'Public'
            ComplianceRequirement = 'LGPD'
            CostCenter = 'CC-8001'
            BusinessUnit = 'Media'
        }
        'InternalIT' = @{
            Weight = 10
            Code = 'it'
            Department = 'IT'
            DataClassification = 'Internal'
            ComplianceRequirement = 'ISO27001'
            CostCenter = 'CC-9001'
            BusinessUnit = 'IT'
        }
    }
    
    # Aplicações típicas por tipo de negócio
    Applications = @{
        'ECommerce' = @('WebStore', 'PaymentGateway', 'InventorySystem', 'RecommendationEngine', 'CustomerPortal')
        'FinancialServices' = @('CoreBanking', 'RiskManagement', 'TradingPlatform', 'ComplianceSystem', 'CustomerPortal')
        'Healthcare' = @('EHR', 'PatientPortal', 'DiagnosticSystem', 'PharmacySystem', 'TelehealthPlatform')
        'Education' = @('LMS', 'StudentPortal', 'GradeSystem', 'LibrarySystem', 'ResearchPlatform')
        'Manufacturing' = @('ERP', 'MES', 'QualitySystem', 'SupplyChain', 'MaintenanceSystem')
        'Logistics' = @('WMS', 'TMS', 'TrackingSystem', 'RouteOptimization', 'CustomerPortal')
        'Media' = @('CMS', 'StreamingPlatform', 'ContentDelivery', 'AnalyticsPlatform', 'SubscriptionSystem')
        'InternalIT' = @('HelpDesk', 'AssetManagement', 'MonitoringSystem', 'BackupSystem', 'SecurityPlatform')
    }
    
    # Proprietários típicos por departamento
    Owners = @{
        'Digital' = @('digital.team', 'ecommerce.lead', 'digital.architect')
        'Finance' = @('finance.systems', 'treasury.team', 'finance.architect')
        'Clinical' = @('clinical.systems', 'healthcare.lead', 'medical.architect')
        'Academic' = @('academic.systems', 'education.lead', 'learning.architect')
        'Operations' = @('operations.team', 'manufacturing.lead', 'ops.architect')
        'Supply Chain' = @('logistics.team', 'supply.lead', 'logistics.architect')
        'Content' = @('media.team', 'content.lead', 'media.architect')
        'IT' = @('platform.team', 'infrastructure.lead', 'it.architect')
    }
}

# Função para selecionar valor baseado em peso
function Get-WeightedRandomSelection {
    param(
        [hashtable]$WeightedOptions
    )
    
    $totalWeight = ($WeightedOptions.Values | ForEach-Object { $_.Weight } | Measure-Object -Sum).Sum
    $randomValue = Get-Random -Minimum 1 -Maximum ($totalWeight + 1)
    
    $currentWeight = 0
    foreach ($option in $WeightedOptions.GetEnumerator()) {
        $currentWeight += $option.Value.Weight
        if ($randomValue -le $currentWeight) {
            return @{
                Name = $option.Key
                Config = $option.Value
            }
        }
    }
    
    # Fallback para o primeiro item se algo der errado
    $firstOption = $WeightedOptions.GetEnumerator() | Select-Object -First 1
    return @{
        Name = $firstOption.Key
        Config = $firstOption.Value
    }
}

# Função aprimorada para gerar tags robustas
function New-ResourceTags {
    param(
        [string]$ServiceType,
        [string]$ResourceName,
        [string]$ResourceGroup,
        [string]$Location
    )
    
    # Selecionar ambiente e tipo de negócio baseado em pesos
    $selectedEnvironment = Get-WeightedRandomSelection -WeightedOptions $script:TagConfiguration.Environments
    $selectedBusiness = Get-WeightedRandomSelection -WeightedOptions $script:TagConfiguration.BusinessTypes
    
    $envName = $selectedEnvironment.Name
    $envConfig = $selectedEnvironment.Config
    $businessName = $selectedBusiness.Name
    $businessConfig = $selectedBusiness.Config
    
    # Selecionar aplicação relevante para o tipo de negócio
    $applications = $script:TagConfiguration.Applications[$businessName]
    $selectedApplication = $applications | Get-Random
    
    # Selecionar proprietário baseado no departamento
    $owners = $script:TagConfiguration.Owners[$businessConfig.Department]
    $selectedOwner = $owners | Get-Random
    
    # Gerar ID único do projeto
    $projectId = "PRJ-$($businessConfig.Code.ToUpper())-$(Get-Random -Min 1000 -Max 9999)"
    
    # Gerar data de criação dentro dos últimos 12 meses
    $creationDate = (Get-Date).AddDays(-(Get-Random -Min 1 -Max 365)).ToString('yyyy-MM-dd')
    
    # Determinar data de revisão baseada no ambiente
    $reviewIntervalDays = switch ($envName) {
        'Production' { 90 }
        'Staging' { 180 }
        'Development' { 365 }
        'Testing' { 180 }
        'Sandbox' { 365 }
        'DR' { 90 }
        default { 180 }
    }
    $nextReview = ([DateTime]$creationDate).AddDays($reviewIntervalDays).ToString('yyyy-MM-dd')
    
    # Construir tags estruturadas
    $tags = [ordered]@{
        # Classificação primária
        'Environment' = $envName
        'BusinessType' = $businessName
        'Application' = $selectedApplication
        
        # Informações organizacionais
        'Department' = $businessConfig.Department
        'BusinessUnit' = $businessConfig.BusinessUnit
        'CostCenter' = $businessConfig.CostCenter
        'ProjectId' = $projectId
        'Owner' = $selectedOwner
        
        # Classificação técnica
        'ServiceType' = $ServiceType
        'Criticality' = $envConfig.CriticalityLevel
        'DataClassification' = $businessConfig.DataClassification
        'BackupPolicy' = $envConfig.BackupPolicy
        'MonitoringLevel' = $envConfig.MonitoringLevel
        
        # Compliance e segurança
        'ComplianceRequirement' = $businessConfig.ComplianceRequirement
        'SecurityZone' = if ($businessConfig.DataClassification -eq 'Restricted') { 'DMZ-Restricted' } 
                        elseif ($businessConfig.DataClassification -eq 'Confidential') { 'DMZ-Confidential' }
                        else { 'Internal' }
        
        # Gestão financeira
        'BillingProfile' = "$($businessConfig.Code)-$($envConfig.Code)"
        'CostAllocation' = "$($businessConfig.BusinessUnit)-$($businessConfig.Department)"
        'BudgetCode' = "BDG-$($businessConfig.Code.ToUpper())-$((Get-Date).Year)"
        
        # Informações de ciclo de vida
        'CreatedDate' = $creationDate
        'LastReviewed' = $creationDate
        'NextReview' = $nextReview
        'LifecycleStage' = switch ($envName) {
            'Sandbox' { 'Experimental' }
            'Development' { 'Development' }
            'Testing' { 'Testing' }
            'Staging' { 'PreProduction' }
            'Production' { 'Production' }
            'DR' { 'Production' }
            default { 'Unknown' }
        }
        
        # Automação e operações
        'AutoShutdown' = if ($envName -in @('Development', 'Testing', 'Sandbox')) { 'Enabled' } else { 'Disabled' }
        'AutoScale' = if ($envName -in @('Production', 'Staging')) { 'Enabled' } else { 'Disabled' }
        'MaintenanceWindow' = switch ($envName) {
            'Production' { 'Sunday-02:00-04:00' }
            'Staging' { 'Saturday-20:00-22:00' }
            default { 'Anytime' }
        }
        
        # Metadados adicionais
        'Region' = $Location
        'ResourceGroup' = $ResourceGroup
        'ManagedBy' = 'FinOpsSimulator'
        'CreatedBy' = 'FinOpsSimulator-v4'
        'LastModified' = (Get-Date).ToString('yyyy-MM-dd HH:mm:ss')
    }
    
    return $tags
}

# Função para aplicar tags específicas por tipo de serviço
function Add-ServiceSpecificTags {
    param(
        [hashtable]$BaseTags,
        [string]$ServiceType,
        [string]$ResourceName
    )
    
    $serviceTags = @{}
    
    switch ($ServiceType) {
        'VirtualMachines' {
            $serviceTags['VMSize'] = @('Standard_B2s', 'Standard_D2s_v3', 'Standard_F4s_v2', 'Standard_E4s_v3') | Get-Random
            $serviceTags['OperatingSystem'] = @('Windows Server 2019', 'Windows Server 2022', 'Ubuntu 20.04', 'RHEL 8') | Get-Random
            $serviceTags['PatchGroup'] = "PatchGroup-$(Get-Random -Min 1 -Max 4)"
            $serviceTags['AntivirusPolicy'] = if ($serviceTags['OperatingSystem'] -like '*Windows*') { 'WindowsDefender' } else { 'ClamAV' }
        }
        'SQLDatabases' {
            $serviceTags['DatabaseEngine'] = 'SQL Server'
            $serviceTags['ServiceTier'] = @('Basic', 'Standard', 'Premium', 'GeneralPurpose', 'BusinessCritical') | Get-Random
            $serviceTags['BackupRetention'] = switch ($BaseTags['Environment']) {
                'Production' { '35-days' }
                'Staging' { '14-days' }
                default { '7-days' }
            }
            $serviceTags['EncryptionEnabled'] = if ($BaseTags['DataClassification'] -in @('Restricted', 'Confidential')) { 'Yes' } else { 'No' }
        }
        'StorageAccounts' {
            $serviceTags['StorageTier'] = @('Hot', 'Cool', 'Archive') | Get-Random
            $serviceTags['Replication'] = @('LRS', 'GRS', 'RA-GRS', 'ZRS') | Get-Random
            $serviceTags['AccessTier'] = @('Hot', 'Cool') | Get-Random
            $serviceTags['EncryptionScope'] = "EncScope-$($BaseTags['Environment'])"
        }
        'AKS' {
            $serviceTags['KubernetesVersion'] = @('1.24.6', '1.25.2', '1.26.1') | Get-Random
            $serviceTags['NodePoolType'] = @('System', 'User') | Get-Random
            $serviceTags['NetworkPolicy'] = 'Azure'
            $serviceTags['ContainerInsights'] = 'Enabled'
        }
        'AppService' {
            $serviceTags['Runtime'] = @('.NET 6', '.NET Framework 4.8', 'Node.js 18', 'Python 3.9', 'PHP 8.1') | Get-Random
            $serviceTags['AppServicePlan'] = @('Basic', 'Standard', 'Premium', 'PremiumV2', 'PremiumV3') | Get-Random
            $serviceTags['AlwaysOn'] = if ($BaseTags['Environment'] -eq 'Production') { 'Enabled' } else { 'Disabled' }
        }
    }
    
    # Mesclar tags específicas do serviço com as tags base
    foreach ($key in $serviceTags.Keys) {
        $BaseTags[$key] = $serviceTags[$key]
    }
    
    return $BaseTags
}

#endregion


#region Configuration and Setup






# Configuração de serviços Azure e suas métricas
$script:ServiceConfig = @{
    'VirtualMachines' = @{
        Prefix = 'VM'
        Metrics = @('CPU_Percent', 'Memory_Percent', 'Disk_IOPS', 'Network_In_MB', 'Network_Out_MB')
        CostRange = @(50, 2000)
        OptimizationRules = @{
            'CPU_Percent' = @{ Low = 20; High = 80; LowAction = 'Downsize'; HighAction = 'ScaleUp' }
            'Memory_Percent' = @{ Low = 30; High = 85; LowAction = 'Optimize'; HighAction = 'AddMemory' }
        }
    }
    'SQLDatabases' = @{
        Prefix = 'SQLDB'
        Metrics = @('DTU_Percent', 'CPU_Percent', 'Storage_Percent', 'Connection_Count', 'Deadlock_Count')
        CostRange = @(100, 5000)
        OptimizationRules = @{
            'DTU_Percent' = @{ Low = 15; High = 90; LowAction = 'DowngradeTier'; HighAction = 'UpgradeTier' }
            'CPU_Percent' = @{ Low = 20; High = 85; LowAction = 'ReduceResources'; HighAction = 'ScaleOut' }
        }
    }
    'SQLManagedInstance' = @{
        Prefix = 'SQLMI'
        Metrics = @('vCore_CPU_Percent', 'Memory_Percent', 'Storage_Used_GB', 'IO_Requests', 'Log_Write_Percent')
        CostRange = @(500, 15000)
        OptimizationRules = @{
            'vCore_CPU_Percent' = @{ Low = 25; High = 80; LowAction = 'ReducevCores'; HighAction = 'AddvCores' }
        }
    }
    'PostgreSQL' = @{
        Prefix = 'PSQL'
        Metrics = @('CPU_Percent', 'Memory_Percent', 'Storage_Percent', 'Active_Connections', 'IOPS')
        CostRange = @(75, 3000)
        OptimizationRules = @{
            'CPU_Percent' = @{ Low = 20; High = 85; LowAction = 'ReduceCompute'; HighAction = 'ScaleCompute' }
        }
    }
    'VMSS' = @{
        Prefix = 'VMSS'
        Metrics = @('CPU_Percent', 'Memory_Percent', 'Instance_Count', 'Network_Total_MB', 'Disk_Queue_Depth')
        CostRange = @(200, 8000)
        OptimizationRules = @{
            'Instance_Count' = @{ Low = 2; High = 50; LowAction = 'ReduceInstances'; HighAction = 'OptimizeScaling' }
        }
    }
    'StorageAccounts' = @{
        Prefix = 'SA'
        Metrics = @('Used_Capacity_GB', 'Transaction_Count', 'Ingress_GB', 'Egress_GB', 'Blob_Count')
        CostRange = @(10, 1500)
        OptimizationRules = @{
            'Used_Capacity_GB' = @{ Low = 100; High = 4000; LowAction = 'ArchiveData'; HighAction = 'OptimizeTier' }
        }
    }
    'LogAnalytics' = @{
        Prefix = 'LAW'
        Metrics = @('Daily_Ingestion_GB', 'Retention_GB', 'Query_Count', 'Data_Export_GB', 'Alert_Count')
        CostRange = @(25, 2000)
        OptimizationRules = @{
            'Daily_Ingestion_GB' = @{ Low = 1; High = 100; LowAction = 'ReduceRetention'; HighAction = 'OptimizeIngestion' }
        }
    }
    'AKS' = @{
        Prefix = 'AKS'
        Metrics = @('Node_CPU_Percent', 'Node_Memory_Percent', 'Pod_Count', 'Node_Count', 'Storage_Used_GB')
        CostRange = @(150, 6000)
        OptimizationRules = @{
            'Node_CPU_Percent' = @{ Low = 30; High = 75; LowAction = 'ReduceNodes'; HighAction = 'ScaleNodes' }
            'Pod_Count' = @{ Low = 10; High = 200; LowAction = 'OptimizePods'; HighAction = 'AddNodes' }
        }
    }
    'AppService' = @{
        Prefix = 'AS'
        Metrics = @('CPU_Percent', 'Memory_Percent', 'Request_Count', 'Response_Time_MS', 'Http_Errors')
        CostRange = @(30, 1200)
        OptimizationRules = @{
            'CPU_Percent' = @{ Low = 15; High = 80; LowAction = 'DowngradePlan'; HighAction = 'ScaleUp' }
        }
    }
    'CosmosDB' = @{
        Prefix = 'CDB'
        Metrics = @('RU_Consumption', 'Storage_Used_GB', 'Request_Count', 'Throttle_Rate', 'Replication_Lag_MS')
        CostRange = @(100, 5000)
        OptimizationRules = @{
            'RU_Consumption' = @{ Low = 100; High = 8000; LowAction = 'ReduceRUs'; HighAction = 'OptimizeQueries' }
        }
    }
}

# Configuração de densidade de recursos
$script:DensityConfig = @{
    'Low'    = @{ MinResources = 1; MaxResources = 3 }
    'Medium' = @{ MinResources = 2; MaxResources = 8 }
    'High'   = @{ MinResources = 5; MaxResources = 15 }
}

# Configuração de logging
$script:LogConfig = @{
    'Debug'   = 0
    'Info'    = 1
    'Warning' = 2
    'Error'   = 3
}

#endregion

#region Utility Functions

function Write-Log {
    param(
        [string]$Message,
        [ValidateSet("Debug", "Info", "Warning", "Error")]
        [string]$Level = "Info",
        [switch]$NoNewLine
    )
    
    if ($script:LogConfig[$Level] -ge $script:LogConfig[$LogLevel]) {
        $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
        $color = switch ($Level) {
            "Debug"   { "Gray" }
            "Info"    { "Cyan" }
            "Warning" { "Yellow" }
            "Error"   { "Red" }
        }
        
        $logMessage = "[$timestamp] [$Level] $Message"
        Write-Host $logMessage -ForegroundColor $color -NoNewline:$NoNewLine
    }
}

function Test-Prerequisites {
    Write-Log "🔍 Verificando pré-requisitos..." -Level Info
    
    # Verificar se pasta de output pode ser criada
    try {
        if (-not (Test-Path $OutputFolder)) {
            New-Item -ItemType Directory -Path $OutputFolder -Force | Out-Null
            Write-Log "📂 Pasta de saída criada: $OutputFolder" -Level Info
        }
    }
    catch {
        Write-Log "❌ Erro ao criar pasta de saída: $($_.Exception.Message)" -Level Error
        return $false
    }
    
    # Verificar módulos necessários se não for modo simulação
    if (-not $SimulationMode) {
        $requiredModules = @('Az.Accounts', 'Az.ResourceGraph', 'Az.Billing')
        foreach ($module in $requiredModules) {
            if (-not (Get-Module -ListAvailable -Name $module)) {
                Write-Log "❌ Módulo necessário não encontrado: $module" -Level Error
                Write-Log "💡 Execute: Install-Module $module -Scope CurrentUser" -Level Warning
                return $false
            }
        }
    }
    
    Write-Log "✅ Pré-requisitos atendidos" -Level Info
    return $true
}

function Get-RandomWeightedValue {
    param(
        [int]$Min,
        [int]$Max,
        [string]$Distribution = "Normal"
    )
    
    switch ($Distribution) {
        "Normal" {
            # Distribuição normal usando Box-Muller transform
            $u1 = Get-Random -Minimum 0.0 -Maximum 1.0
            $u2 = Get-Random -Minimum 0.0 -Maximum 1.0
            $z = [Math]::Sqrt(-2 * [Math]::Log($u1)) * [Math]::Cos(2 * [Math]::PI * $u2)
            $mean = ($Max + $Min) / 2
            $stddev = ($Max - $Min) / 6
            $value = $mean + $stddev * $z
            return [Math]::Max($Min, [Math]::Min($Max, $value))
        }
        "Exponential" {
            $lambda = 2.0 / ($Max - $Min)
            $u = Get-Random -Minimum 0.0 -Maximum 1.0
            $value = -[Math]::Log($u) / $lambda + $Min
            return [Math]::Min($Max, $value)
        }
        default {
            return Get-Random -Minimum $Min -Maximum $Max
        }
    }
}

#endregion

#region Data Generation Functions

function Get-Subscriptions {
    param([bool]$IsSimulation)
    
    Write-Log "🔄 Obtendo subscriptions (Simulação=$IsSimulation)" -Level Info
    
    if ($IsSimulation) {
        $subscriptions = 1..$SubscriptionCount | ForEach-Object { 
            [PSCustomObject]@{ 
                Name = "Subscription-$('{0:D3}' -f $_)"
                Id = "sub-$('{0:D8}' -f $_)-$(Get-Random -Max 9999)"
                State = "Enabled"
                TenantId = "tenant-$((1..4 | ForEach-Object { Get-Random -Max 999 }) -join '-')"
            } 
        }
        Write-Log "📊 Geradas $($subscriptions.Count) subscriptions simuladas" -Level Info
        return $subscriptions
    }
    else {
        try {
            Import-Module Az.Accounts -ErrorAction Stop
            if (-not (Get-AzContext)) {
                Write-Log "🔐 Conectando ao Azure..." -Level Info
                Connect-AzAccount | Out-Null
            }
            $subscriptions = Get-AzSubscription | Where-Object { $_.State -eq "Enabled" } | Select-Object Name, Id, State, TenantId
            Write-Log "📊 Obtidas $($subscriptions.Count) subscriptions do Azure" -Level Info
            return $subscriptions
        }
        catch {
            Write-Log "❌ Erro ao conectar ao Azure: $($_.Exception.Message)" -Level Error
            return @()
        }
    }
}

function New-ResourceInstances {
    param(
        [array]$Subscriptions,
        [string]$ServiceType,
        [hashtable]$ServiceConfig
    )
    
    $resources = @()
    $densitySettings = $script:DensityConfig[$ResourceDensity]
    
    Write-Log "🏷️  Gerando recursos $ServiceType com tags aprimoradas" -Level Info
    
    foreach ($sub in $Subscriptions) {
        $resourceCount = Get-Random -Minimum $densitySettings.MinResources -Maximum $densitySettings.MaxResources
        
        1..$resourceCount | ForEach-Object {
            $resourceId = [System.Guid]::NewGuid().ToString().Substring(0, 8).ToUpper()
            $resourceName = "$($ServiceConfig.Prefix)-$resourceId"
            $resourceGroup = "rg-$ServiceType-$(Get-Random -Max 99)"
            $location = @('East US', 'West US 2', 'Central US', 'North Europe', 'West Europe', 'Southeast Asia')[(Get-Random -Max 6)]
            
            # Gerar tags base estruturadas
            $baseTags = New-ResourceTags -ServiceType $ServiceType -ResourceName $resourceName -ResourceGroup $resourceGroup -Location $location
            
            # Adicionar tags específicas do serviço
            $finalTags = Add-ServiceSpecificTags -BaseTags $baseTags -ServiceType $ServiceType -ResourceName $resourceName
            
            $resources += [PSCustomObject]@{
                SubscriptionId = $sub.Id
                SubscriptionName = $sub.Name
                ServiceType = $ServiceType
                ResourceName = $resourceName
                ResourceGroup = $resourceGroup
                Location = $location
                Tags = $finalTags
            }
        }
    }
    
    # Mostrar estatísticas de distribuição das tags
    $envDistribution = $resources.Tags | Group-Object { $_['Environment'] } | ForEach-Object { "$($_.Name): $($_.Count)" }
    $businessDistribution = $resources.Tags | Group-Object { $_['BusinessType'] } | ForEach-Object { "$($_.Name): $($_.Count)" }
    
    Write-Log "   📊 Distribuição por ambiente: $($envDistribution -join ', ')" -Level Info
    Write-Log "   🏢 Distribuição por negócio: $($businessDistribution -join ', ')" -Level Info
    Write-Log "🏗️  Criadas $($resources.Count) instâncias de $ServiceType com tags estruturadas" -Level Debug
    
    return $resources
}

# Função para gerar relatório de tags
function New-TagAnalysisReport {
    param(
        [array]$Resources
    )
    
    Write-Log "🏷️  Gerando relatório de análise de tags" -Level Info
    
    $tagAnalysis = @{
        EnvironmentDistribution = $Resources.Tags | Group-Object { $_['Environment'] } | ForEach-Object {
            [PSCustomObject]@{
                Environment = $_.Name
                ResourceCount = $_.Count
                Percentage = [Math]::Round(($_.Count / $Resources.Count) * 100, 2)
            }
        } | Sort-Object ResourceCount -Descending
        
        BusinessTypeDistribution = $Resources.Tags | Group-Object { $_['BusinessType'] } | ForEach-Object {
            [PSCustomObject]@{
                BusinessType = $_.Name
                ResourceCount = $_.Count
                Percentage = [Math]::Round(($_.Count / $Resources.Count) * 100, 2)
            }
        } | Sort-Object ResourceCount -Descending
        
        CriticalityDistribution = $Resources.Tags | Group-Object { $_['Criticality'] } | ForEach-Object {
            [PSCustomObject]@{
                Criticality = $_.Name
                ResourceCount = $_.Count
                Percentage = [Math]::Round(($_.Count / $Resources.Count) * 100, 2)
            }
        } | Sort-Object ResourceCount -Descending
        
        DepartmentDistribution = $Resources.Tags | Group-Object { $_['Department'] } | ForEach-Object {
            [PSCustomObject]@{
                Department = $_.Name
                ResourceCount = $_.Count
                Percentage = [Math]::Round(($_.Count / $Resources.Count) * 100, 2)
            }
        } | Sort-Object ResourceCount -Descending
        
        ComplianceRequirements = $Resources.Tags | Group-Object { $_['ComplianceRequirement'] } | ForEach-Object {
            [PSCustomObject]@{
                ComplianceRequirement = $_.Name
                ResourceCount = $_.Count
                Percentage = [Math]::Round(($_.Count / $Resources.Count) * 100, 2)
            }
        } | Sort-Object ResourceCount -Descending
    }
    
    return $tagAnalysis
}

function New-CostData {
    param(
        [array]$Resources,
        [int]$MonthsBack,
        [hashtable]$ServiceConfig
    )
    
    Write-Log "💰 Gerando dados de custo para $($Resources.Count) recursos" -Level Info
    $costData = @()
    $startDate = (Get-Date).AddMonths(-$MonthsBack)
    $endDate = Get-Date
    
    foreach ($resource in $Resources) {
        # Gerar padrão de custo base para o recurso
        $baseCost = Get-RandomWeightedValue -Min $ServiceConfig.CostRange[0] -Max $ServiceConfig.CostRange[1] -Distribution "Normal"
        
        # Gerar dados diários
        for ($date = $startDate; $date -le $endDate; $date = $date.AddDays(1)) {
            # Adicionar variação sazonal e diária
            $seasonalFactor = 1 + 0.2 * [Math]::Sin(($date.DayOfYear / 365.25) * 2 * [Math]::PI)
            $weeklyFactor = if ($date.DayOfWeek -in @('Saturday', 'Sunday')) { 0.7 } else { 1.0 }
            $randomVariation = Get-Random -Minimum 0.8 -Maximum 1.2
            
            $dailyCost = $baseCost * $seasonalFactor * $weeklyFactor * $randomVariation / 30 # Custo diário
            
            $costData += [PSCustomObject]@{
                SubscriptionId = $resource.SubscriptionId
                SubscriptionName = $resource.SubscriptionName
                ServiceType = $resource.ServiceType
                ResourceName = $resource.ResourceName
                ResourceGroup = $resource.ResourceGroup
                Location = $resource.Location
                Date = $date
                MonthYear = $date.ToString('yyyy-MM')
                Cost = [Math]::Round($dailyCost, 2)
                Currency = 'BRL'
                Tags     = (
                    $resource.Tags.GetEnumerator() |
                      ForEach-Object { "$($_.Key)=$($_.Value)" }
                  ) -join ';'
                #Tags = $resource.Tags
            }
        }
    }
    
    Write-Log "📈 Gerados $($costData.Count) registros de custo" -Level Info
    return $costData
}


function New-MetricsData {
    param(
        [array]$Resources,
        [int]$MonthsBack,
        [hashtable]$ServiceConfig,
        [int]$IntervalMinutes = 120  # AUMENTADO de 30 para 120 minutos
    )
    
    Write-Log "📊 Gerando métricas para $($Resources.Count) recursos (intervalo: ${IntervalMinutes}min)" -Level Info
    
    # OTIMIZAÇÃO 1: Calcular estatísticas primeiro
    $startDate = (Get-Date).AddMonths(-$MonthsBack)
    $endDate = Get-Date
    $interval = [TimeSpan]::FromMinutes($IntervalMinutes)
    $totalDays = ($endDate - $startDate).TotalDays
    $totalPoints = [Math]::Ceiling($totalDays * 24 * 60 / $IntervalMinutes)
    
    Write-Log "   📈 Período: $($startDate.ToString('yyyy-MM-dd')) a $($endDate.ToString('yyyy-MM-dd'))" -Level Info
    Write-Log "   📊 Estimativa: $totalPoints pontos por recurso, $($ServiceConfig.Metrics.Count) métricas" -Level Info
    Write-Log "   🔢 Total estimado: $($Resources.Count * $totalPoints * $ServiceConfig.Metrics.Count) registros" -Level Info
    
    # OTIMIZAÇÃO 2: Usar ArrayList ao invés de array para melhor performance
    $metricsData = New-Object System.Collections.ArrayList
    
    # OTIMIZAÇÃO 3: Processar em lotes menores
    $batchSize = 10
    $resourceBatches = @()
    for ($i = 0; $i -lt $Resources.Count; $i += $batchSize) {
        $end = [Math]::Min($i + $batchSize - 1, $Resources.Count - 1)
        $resourceBatches += ,($Resources[$i..$end])
    }
    
    $batchCounter = 0
    foreach ($batch in $resourceBatches) {
        $batchCounter++
        Write-Log "   📦 Processando lote $batchCounter/$($resourceBatches.Count) ($($batch.Count) recursos)" -Level Info
        
        # OTIMIZAÇÃO 4: Reduzir cálculos repetitivos
        foreach ($resource in $batch) {
            # Gerar padrões base UMA VEZ para cada recurso
            $metricPatterns = @{}
            foreach ($metric in $ServiceConfig.Metrics) {
                $metricPatterns[$metric] = @{
                    BaseValue = Get-Random -Minimum 10 -Maximum 60
                    Volatility = Get-Random -Minimum 0.1 -Maximum 0.3
                    TrendFactor = Get-Random -Minimum -0.1 -Maximum 0.1
                }
            }
            
            # OTIMIZAÇÃO 5: Pré-calcular timestamps
            $timestamps = @()
            for ($timestamp = $startDate; $timestamp -le $endDate; $timestamp = $timestamp.Add($interval)) {
                $timestamps += $timestamp
            }
            
            # OTIMIZAÇÃO 6: Processar todas as métricas de uma vez por timestamp
            $pointCounter = 0
            foreach ($timestamp in $timestamps) {
                $pointCounter++
                
                # Mostrar progresso a cada 500 pontos
                if ($pointCounter % 500 -eq 0) {
                    Write-Log "     ⏳ $($resource.ResourceName): $pointCounter/$($timestamps.Count) pontos" -Level Debug
                }
                
                # Cálculos comuns para o timestamp
                $timeProgress = ($timestamp - $startDate).TotalDays / $totalDays
                $seasonalVariation = 0.2 * [Math]::Sin(($timestamp.Hour / 24.0) * 2 * [Math]::PI)
                
                foreach ($metric in $ServiceConfig.Metrics) {
                    $pattern = $metricPatterns[$metric]
                    
                    # Valor com tendência
                    $trendValue = $pattern.BaseValue * (1 + $pattern.TrendFactor * $timeProgress)
                    
                    # Ruído
                    $noise = (Get-Random -Minimum -1.0 -Maximum 1.0) * $pattern.Volatility * $trendValue
                    
                    $finalValue = $trendValue + $seasonalVariation * $trendValue + $noise
                    $finalValue = [Math]::Max(0, $finalValue)
                    
                    # Ajustes por tipo de métrica
                    if ($metric -like "*_Percent*") {
                        $finalValue = [Math]::Min(100, $finalValue)
                    } elseif ($metric -like "*_Count*") {
                        $finalValue = [Math]::Round($finalValue)
                    }
                    
                    # OTIMIZAÇÃO 7: Usar Add() ao invés de +=
                    $null = $metricsData.Add([PSCustomObject]@{
                        SubscriptionId = $resource.SubscriptionId
                        SubscriptionName = $resource.SubscriptionName
                        ServiceType = $resource.ServiceType
                        ResourceName = $resource.ResourceName
                        ResourceGroup = $resource.ResourceGroup
                        MetricName = $metric
                        Value = [Math]::Round($finalValue, 2)
                        Timestamp = $timestamp
                        Unit = Get-MetricUnit $metric
                    })
                }
            }
        }
        
        # OTIMIZAÇÃO 8: Garbage collection entre lotes
        [System.GC]::Collect()
    }
    
    Write-Log "📊 Gerados $($metricsData.Count) pontos de métricas" -Level Info
    return $metricsData.ToArray()
}

# OTIMIZAÇÃO ADICIONAL: Função para amostragem de dados
function New-SampledMetricsData {
    param(
        [array]$Resources,
        [int]$MonthsBack,
        [hashtable]$ServiceConfig,
        [int]$SamplePercentage = 10  # Usar apenas 10% dos recursos para teste
    )
    
    Write-Log "🔬 Modo AMOSTRAGEM: Usando $SamplePercentage% dos recursos" -Level Warning
    
    $sampleSize = [Math]::Ceiling($Resources.Count * $SamplePercentage / 100)
    $sampledResources = $Resources | Get-Random -Count $sampleSize
    
    Write-Log "📊 Amostra selecionada: $($sampledResources.Count) de $($Resources.Count) recursos" -Level Info
    
    return New-MetricsData -Resources $sampledResources -MonthsBack $MonthsBack -ServiceConfig $ServiceConfig -IntervalMinutes 240
}

# OTIMIZAÇÃO ALTERNATIVA: Geração de métricas sintéticas mais eficiente
function New-FastMetricsData {
    param(
        [array]$Resources,
        [int]$MonthsBack,
        [hashtable]$ServiceConfig,
        [int]$DailyPoints = 96  # Apenas 96 pontos por dia (4 por hora)
    )
    
    Write-Log "⚡ Modo RÁPIDO: Gerando métricas sintéticas otimizadas" -Level Info
    
    $metricsData = New-Object System.Collections.ArrayList
    $startDate = (Get-Date).AddMonths(-$MonthsBack)
    $totalDays = ((Get-Date) - $startDate).Days
    
    foreach ($resource in $Resources) {
        foreach ($metric in $ServiceConfig.Metrics) {
            # Gerar curva de tendência para todo o período
            $baseValue = Get-Random -Minimum 20 -Maximum 80
            $volatility = Get-Random -Minimum 5 -Maximum 20
            
            for ($day = 0; $day -lt $totalDays; $day += 3) {  # A cada 3 dias
                $date = $startDate.AddDays($day)
                
                # Valor com variação temporal
                $seasonalFactor = 1 + 0.3 * [Math]::Sin(($day / 365.0) * 2 * [Math]::PI)
                $randomFactor = Get-Random -Minimum 0.7 -Maximum 1.3
                $value = $baseValue * $seasonalFactor * $randomFactor
                
                # Ajustes finais
                if ($metric -like "*_Percent*") {
                    $value = [Math]::Min(100, [Math]::Max(0, $value))
                } elseif ($metric -like "*_Count*") {
                    $value = [Math]::Round($value)
                }
                
                $null = $metricsData.Add([PSCustomObject]@{
                    SubscriptionId = $resource.SubscriptionId
                    SubscriptionName = $resource.SubscriptionName
                    ServiceType = $resource.ServiceType
                    ResourceName = $resource.ResourceName
                    ResourceGroup = $resource.ResourceGroup
                    MetricName = $metric
                    Value = [Math]::Round($value, 2)
                    Timestamp = $date
                    Unit = Get-MetricUnit $metric
                })
            }
        }
    }
    
    Write-Log "⚡ Gerados $($metricsData.Count) pontos de métricas (modo rápido)" -Level Info
    return $metricsData.ToArray()
}

function Get-MetricUnit {
    param([string]$MetricName)
    
    switch -Wildcard ($MetricName) {
        "*_Percent*" { return "Percent" }
        "*_Count*" { return "Count" }
        "*_GB*" { return "GB" }
        "*_MB*" { return "MB" }
        "*_MS*" { return "Milliseconds" }
        "*_IOPS*" { return "IOPS" }
        "*_RU*" { return "RU" }
        default { return "Count" }
    }
}

function New-RecommendationData {
    param(
        [array]$MetricsData,
        [array]$CostData,
        [hashtable]$ServiceConfig
    )
    
    Write-Log "🎯 Gerando recomendações de otimização" -Level Info
    $recommendations = @()
    
    # Agrupar métricas por recurso
    $metricsByResource = $MetricsData | Group-Object SubscriptionId, ServiceType, ResourceName
    
    Write-Log "   📊 Processando $($metricsByResource.Count) recursos únicos" -Level Info
    
    foreach ($resourceGroup in $metricsByResource) {
        $resource = $resourceGroup.Group[0]
        $serviceType = $resource.ServiceType
        
        Write-Log "   🔍 Analisando $serviceType - $($resource.ResourceName)" -Level Debug
        
        # CORREÇÃO: Buscar configuração do serviço diretamente pela chave
        $service = $ServiceConfig[$serviceType]
        
        if (-not $service) { 
            Write-Log "   ⚠️  Configuração não encontrada para $serviceType" -Level Debug
            continue 
        }
        
        Write-Log "   ✅ Configuração encontrada para $serviceType (Regras: $($service.OptimizationRules.Keys.Count))" -Level Debug
        
        # Calcular estatísticas das métricas
        $resourceMetrics = $resourceGroup.Group | Group-Object MetricName
        
        foreach ($metricGroup in $resourceMetrics) {
            $metricName = $metricGroup.Name
            $values = $metricGroup.Group.Value
            
            if ($values.Count -eq 0) { continue }
            
            $stats = @{
                Average = [Math]::Round(($values | Measure-Object -Average).Average, 2)
                Maximum = ($values | Measure-Object -Maximum).Maximum
                Minimum = ($values | Measure-Object -Minimum).Minimum
                P95 = Get-Percentile $values 95
                P99 = Get-Percentile $values 99
            }
            
            Write-Log "   📈 $metricName - Média: $($stats.Average), P95: $($stats.P95)" -Level Debug
            
            # Verificar regras de otimização
            if ($service.OptimizationRules.ContainsKey($metricName)) {
                $rule = $service.OptimizationRules[$metricName]
                $recommendation = $null
                $priority = "Medium"
                $potentialSaving = 0
                
                Write-Log "   🎯 Regra encontrada para $metricName (Low: $($rule.Low), High: $($rule.High))" -Level Debug
                
                if ($stats.Average -lt $rule.Low) {
                    $recommendation = $rule.LowAction
                    $priority = "High"
                    $potentialSaving = Get-Random -Minimum 15 -Maximum 40
                    Write-Log "   💡 Recomendação LOW: $recommendation (Economia: $potentialSaving%)" -Level Debug
                } elseif ($stats.P95 -gt $rule.High) {
                    $recommendation = $rule.HighAction
                    $priority = "Medium"
                    $potentialSaving = 0 # Investimento, não economia
                    Write-Log "   📊 Recomendação HIGH: $recommendation" -Level Debug
                }
                
                if ($recommendation) {
                    # Calcular custo atual do recurso
                    $resourceCost = $CostData | Where-Object { 
                        $_.SubscriptionId -eq $resource.SubscriptionId -and 
                        $_.ResourceName -eq $resource.ResourceName 
                    }
                    $monthlyCost = if ($resourceCost) { 
                        [Math]::Round(($resourceCost | Measure-Object -Property Cost -Sum).Sum, 2) 
                    } else { 0 }
                    
                    $recommendations += [PSCustomObject]@{
                        SubscriptionId = $resource.SubscriptionId
                        SubscriptionName = $resource.SubscriptionName
                        ServiceType = $resource.ServiceType
                        ResourceName = $resource.ResourceName
                        ResourceGroup = $resource.ResourceGroup
                        RecommendationType = $recommendation
                        Description = Get-RecommendationDescription $recommendation $metricName $stats.Average $rule
                        Priority = $priority
                        Category = "Cost Optimization"
                        MetricName = $metricName
                        CurrentValue = $stats.Average
                        Threshold = if ($stats.Average -lt $rule.Low) { $rule.Low } else { $rule.High }
                        MonthlyCostImpact = [Math]::Round($monthlyCost * $potentialSaving / 100, 2)
                        PotentialSavingPercent = $potentialSaving
                        Confidence = "High"
                        GeneratedDate = Get-Date
                    }
                    
                    Write-Log "   ✅ Recomendação criada: $recommendation para $($resource.ResourceName)" -Level Debug
                }
            } else {
                Write-Log "   ⚠️  Nenhuma regra de otimização encontrada para métrica $metricName" -Level Debug
            }
        }
    }
    
    # Estatísticas finais
    $recsByService = $recommendations | Group-Object ServiceType
    foreach ($group in $recsByService) {
        Write-Log "   📋 $($group.Name): $($group.Count) recomendações" -Level Info
    }
    
    Write-Log "✅ Geradas $($recommendations.Count) recomendações" -Level Info
    return $recommendations
}

function Get-Percentile {
    param([array]$Values, [int]$Percentile)
    
    if ($Values.Count -eq 0) { return 0 }
    
    $sorted = $Values | Sort-Object
    $index = [Math]::Ceiling($Percentile / 100 * $Values.Count) - 1
    $index = [Math]::Max(0, [Math]::Min($sorted.Count - 1, $index))
    
    return $sorted[$index]
}

function Get-RecommendationDescription {
    param(
        [string]$Action,
        [string]$MetricName,
        [double]$CurrentValue,
        [hashtable]$Rule
    )
    
    switch ($Action) {
        "Downsize" { return "Resource is underutilized. $MetricName averaging $CurrentValue%. Consider downsizing." }
        "ScaleUp" { return "Resource is over-utilized. $MetricName averaging $CurrentValue%. Consider scaling up." }
        "Shutdown Idle VM" { return "VM appears idle with $MetricName at $CurrentValue%. Consider shutdown or deallocation." }
        "DowngradeTier" { return "Database tier may be oversized. $MetricName averaging $CurrentValue%. Consider downgrade." }
        "UpgradeTier" { return "Database may need more resources. $MetricName at $CurrentValue%. Consider upgrade." }
        "ReduceInstances" { return "Scale set may be over-provisioned. Consider reducing instance count." }
        "ArchiveData" { return "Storage utilization is low at $CurrentValue GB. Consider archiving old data." }
        "OptimizeTier" { return "Storage tier optimization opportunity identified." }
        default { return "Optimization opportunity identified for $MetricName (current: $CurrentValue)." }
    }
}

#endregion

#region Export Functions

function Export-ToCSV {
    param(
        [array]$Data,
        [string]$FilePath,
        [string]$Delimiter = ";"
    )
    
    try {
        $Data | Export-Csv -Path $FilePath -Delimiter $Delimiter -NoTypeInformation -Encoding UTF8
        Write-Log "📄 CSV exportado: $FilePath ($($Data.Count) registros)" -Level Info
        return $true
    }
    catch {
        Write-Log "❌ Erro ao exportar CSV: $($_.Exception.Message)" -Level Error
        return $false
    }
}

function Export-ToJSON {
    param(
        [array]$Data,
        [string]$FilePath
    )
    
    try {
        $Data | ConvertTo-Json -Depth 10 -Compress:$false | Out-File -FilePath $FilePath -Encoding UTF8
        Write-Log "📄 JSON exportado: $FilePath ($($Data.Count) registros)" -Level Info
        return $true
    }
    catch {
        Write-Log "❌ Erro ao exportar JSON: $($_.Exception.Message)" -Level Error
        return $false
    }
}

function Export-ToExcel {
    param(
        [hashtable]$DataSets,
        [string]$FilePath
    )
    
    try {
        # Verificar se ImportExcel está disponível
        if (Get-Module -ListAvailable -Name ImportExcel) {
            Import-Module ImportExcel -ErrorAction SilentlyContinue
            
            $excelParams = @{
                Path = $FilePath
                WorksheetName = 'Summary'
                AutoSize = $true
                AutoFilter = $true
                BoldTopRow = $true
                TableStyle = 'Medium2'
            }
            
            # Exportar cada dataset para uma aba separada
            foreach ($datasetName in $DataSets.Keys) {
                $data = $DataSets[$datasetName]
                if ($data.Count -gt 0) {
                    $excelParams.WorksheetName = $datasetName
                    $data | Export-Excel @excelParams -ClearSheet
                    Write-Log "📊 Aba '$datasetName' adicionada ao Excel ($($data.Count) registros)" -Level Debug
                }
            }
            
            Write-Log "📄 Excel exportado: $FilePath" -Level Info
            return $true
        }
        else {
            Write-Log "⚠️ Módulo ImportExcel não disponível. Instale com: Install-Module ImportExcel" -Level Warning
            return $false
        }
    }
    catch {
        Write-Log "❌ Erro ao exportar Excel: $($_.Exception.Message)" -Level Error
        return $false
    }
}

function New-SummaryReport {
    param(
        [array]$CostData,
        [array]$MetricsData,
        [array]$Recommendations,
        [bool]$SimulationMode,
        [int]$MonthsBack,
        [string]$ResourceDensity
    )
    
    Write-Log "📋 Gerando relatório resumo" -Level Info
    
    # VALIDAÇÕES ADICIONADAS
    if ($null -eq $CostData -or $CostData.Count -eq 0) {
        Write-Log "⚠️ CostData está vazio ou nulo" -Level Warning
        $CostData = @()
    }
    
    if ($null -eq $MetricsData -or $MetricsData.Count -eq 0) {
        Write-Log "⚠️ MetricsData está vazio ou nulo" -Level Warning
        $MetricsData = @()
    }
    
    if ($null -eq $Recommendations) {
        Write-Log "⚠️ Recommendations está nulo" -Level Warning
        $Recommendations = @()
    }
    
    # Cálculos de custo com validação
    $totalCost = if ($CostData.Count -gt 0) { 
        ($CostData | Measure-Object -Property Cost -Sum).Sum 
    } else { 0 }
    
    Write-Log "📋 Gerando relatório resumo" -Level Info
    
    # Cálculos de custo
    $totalCost = ($CostData | Measure-Object -Property Cost -Sum).Sum
    $costByService = $CostData | Group-Object ServiceType | ForEach-Object {
        [PSCustomObject]@{
            ServiceType = $_.Name
            TotalCost = [Math]::Round(($_.Group | Measure-Object -Property Cost -Sum).Sum, 2)
            ResourceCount = ($_.Group | Select-Object -Unique ResourceName).Count
        }
    } | Sort-Object TotalCost -Descending
    
    $costBySubscription = $CostData | Group-Object SubscriptionName | ForEach-Object {
        [PSCustomObject]@{
            SubscriptionName = $_.Name
            TotalCost = [Math]::Round(($_.Group | Measure-Object -Property Cost -Sum).Sum, 2)
            ResourceCount = ($_.Group | Select-Object -Unique ResourceName).Count
        }
    } | Sort-Object TotalCost -Descending
    
    # Estatísticas de recomendações
    $totalPotentialSaving = ($Recommendations | Measure-Object -Property MonthlyCostImpact -Sum).Sum
    $recommendationsByPriority = $Recommendations | Group-Object Priority | ForEach-Object {
        [PSCustomObject]@{
            Priority = $_.Name
            Count = $_.Count
            PotentialSaving = [Math]::Round(($_.Group | Measure-Object -Property MonthlyCostImpact -Sum).Sum, 2)
        }
    }
    
    # Métricas por serviço
    $metricsSummary = $MetricsData | Group-Object ServiceType | ForEach-Object {
        [PSCustomObject]@{
            ServiceType = $_.Name
            MetricPoints = $_.Count
            ResourcesMonitored = ($_.Group | Select-Object -Unique ResourceName).Count
            TimeSpan = "$((($_.Group | Measure-Object Timestamp -Minimum).Minimum).ToString('yyyy-MM-dd')) to $((($_.Group | Measure-Object Timestamp -Maximum).Maximum).ToString('yyyy-MM-dd'))"
        }
    }
    
    return @{
        Overview = [PSCustomObject]@{
            GenerationDate = Get-Date
            SimulationMode = $SimulationMode
            MonthsAnalyzed = $MonthsBack
            ResourceDensity = $ResourceDensity
            TotalCost = [Math]::Round($totalCost, 2)
            Currency = 'BRL'
            TotalResources = ($CostData | Select-Object -Unique SubscriptionId, ResourceName).Count
            TotalSubscriptions = ($CostData | Select-Object -Unique SubscriptionId).Count
            TotalRecommendations = $Recommendations.Count
            PotentialMonthlySaving = [Math]::Round($totalPotentialSaving, 2)
            SavingPercentage = if ($totalCost -gt 0) { [Math]::Round(($totalPotentialSaving / $totalCost) * 100, 2) } else { 0 }
        }
        CostByService = $costByService
        CostBySubscription = $costBySubscription
        RecommendationsByPriority = $recommendationsByPriority
        MetricsSummary = $metricsSummary
    }
}

function Show-ProgressBar {
    param(
        [int]$Current,
        [int]$Total,
        [string]$Activity = "Processing",
        [string]$Status = "Please wait..."
    )
    
    $percent = [Math]::Round(($Current / $Total) * 100, 0)
    Write-Progress -Activity $Activity -Status "$Status ($Current/$Total)" -PercentComplete $percent
}

#endregion

#region Main Execution Logic

function Start-FinOpsSimulation {
    param(
        [int]$MonthsBack,
        [bool]$SimulationMode,
        [string]$OutputFolder,
        [int]$SubscriptionCount,
        [string]$ResourceDensity,
        [bool]$IncludeRecommendations,
        [string]$ExportFormat,
        [string]$LogLevel
    )
    
    $startTime = Get-Date
    Write-Log "🚀 Iniciando Simulador FinOps v4.0" -Level Info
    Write-Log "⚙️  Configurações: Meses=$MonthsBack, Simulação=$SimulationMode, Densidade=$ResourceDensity" -Level Info
    
    # Verificar pré-requisitos
    if (-not (Test-Prerequisites)) {
        Write-Log "❌ Pré-requisitos não atendidos. Abortando execução." -Level Error
        return $false
    }
    
    try {
        # 1. Obter subscriptions
        Write-Log "📋 Fase 1/6: Obtendo subscriptions" -Level Info
        $subscriptions = Get-Subscriptions -IsSimulation $SimulationMode
        if ($subscriptions.Count -eq 0) {
            Write-Log "❌ Nenhuma subscription encontrada. Abortando." -Level Error
            return $false
        }
        
        # 2. Gerar recursos para todos os serviços
        Write-Log "🏗️  Fase 2/6: Gerando recursos" -Level Info
        $allResources = @()
        $serviceCounter = 0

        foreach ($serviceType in $script:ServiceConfig.Keys) {
            $serviceCounter++
            Show-ProgressBar -Current $serviceCounter -Total $script:ServiceConfig.Count -Activity "Gerando recursos" -Status "Criando $serviceType"
    
            # USAR A FUNÇÃO APRIMORADA:
            $resources = New-ResourceInstances -Subscriptions $subscriptions -ServiceType $serviceType -ServiceConfig $script:ServiceConfig[$serviceType]
            $allResources += $resources
    
            Write-Log "   ✅ $serviceType : $($resources.Count) recursos criados" -Level Debug
        }

        Write-Progress -Activity "Gerando recursos" -Completed
        
        Write-Log "📊 Total de recursos criados: $($allResources.Count)" -Level Info
        
        # 3. Gerar dados de custo
        Write-Log "💰 Fase 3/6: Gerando dados de custo" -Level Info
        $costData = @()
        $resourceCounter = 0
        $resourceGroups = $allResources | Group-Object ServiceType
        
        foreach ($group in $resourceGroups) {
            $resourceCounter++
            Show-ProgressBar -Current $resourceCounter -Total $resourceGroups.Count -Activity "Gerando custos" -Status "Processando $($group.Name)"
            
            $serviceConfig = $script:ServiceConfig[$group.Name]
            $groupCostData = New-CostData -Resources $group.Group -MonthsBack $MonthsBack -ServiceConfig $serviceConfig
            $costData += $groupCostData
        }
        Write-Progress -Activity "Gerando custos" -Completed
        
        # 4. Gerar dados de métricas
        Write-Log "📈 Fase 4/6: Gerando métricas" -Level Info
        $metricsData = @()
        $resourceCounter = 0
        
        foreach ($group in $resourceGroups) {
            
            $resourceCounter++
            Show-ProgressBar -Current $resourceCounter -Total $resourceGroups.Count -Activity "Gerando métricas" -Status "Processando $($group.Name)"
            
            $serviceConfig = $script:ServiceConfig[$group.Name]
            Write-Log "Chamando função New-FastMetricsData para geração de metricas " -Level Info
            $groupMetricsData = New-FastMetricsData -Resources $group.Group -MonthsBack $MonthsBack -ServiceConfig $serviceConfig
            #$groupMetricsData = New-MetricsData -Resources $group.Group -MonthsBack $MonthsBack -ServiceConfig $serviceConfig
            $metricsData += $groupMetricsData
        }
        Write-Progress -Activity "Gerando métricas" -Completed
        
        # 5. Gerar recomendações (se habilitado)
        $recommendations = @()
        if ($IncludeRecommendations) {
            Write-Log "🎯 Fase 5/6: Gerando recomendações" -Level Info
            $recommendations = New-RecommendationData -MetricsData $metricsData -CostData $costData -ServiceConfig $script:ServiceConfig
        }
        else {
            Write-Log "⏭️  Fase 5/6: Recomendações desabilitadas" -Level Info
        }

        # ADICIONAR após a geração de todos os recursos:
        Write-Log "🏷️  Gerando relatório de análise de tags" -Level Info
        $tagAnalysisReport = New-TagAnalysisReport -Resources $allResources
 

         try {
            Write-Log "📄 Fase 6/6: Gerando relatórios e exportando dados" -Level Info
            $summary = New-SummaryReport -CostData $costData -MetricsData $metricsData -Recommendations $recommendations -SimulationMode $SimulationMode -MonthsBack $MonthsBack -ResourceDensity $ResourceDensity
    
            if ($null -eq $summary) {
                throw "Summary report generation returned null"
            }
    
            Write-Log "🏷️ Gerando relatório de análise de tags" -Level Info
            $tagAnalysisReport = New-TagAnalysisReport -Resources $allResources

            # 6. Gerar relatório resumo e exportar
            Write-Log "📄 Fase 6/6: Gerando relatórios e exportando dados" -Level Info
            $summary = New-SummaryReport -CostData $costData -MetricsData $metricsData -Recommendations $recommendations -SimulationMode $SimulationMode -MonthsBack $MonthsBack -ResourceDensity $ResourceDensity

            # ADICIONAR o relatório de tags DEPOIS da geração do summary
            Write-Log "🏷️ Gerando relatório de análise de tags" -Level Info
            $tagAnalysisReport = New-TagAnalysisReport -Resources $allResources

            # CRIAR O DATASETS PRIMEIRO
            $datasets = @{
                'Summary' = @($summary.Overview)
                'CostData' = $costData
                'MetricsData' = $metricsData
                'CostByService' = $summary.CostByService
                'CostBySubscription' = $summary.CostBySubscription
                'MetricsSummary' = $summary.MetricsSummary
            }

            # DEPOIS ADICIONAR os relatórios de tags
            $datasets['TagAnalysis'] = $tagAnalysisReport.EnvironmentDistribution
            $datasets['BusinessTypeAnalysis'] = $tagAnalysisReport.BusinessTypeDistribution  
            $datasets['CriticalityAnalysis'] = $tagAnalysisReport.CriticalityDistribution
            $datasets['DepartmentAnalysis'] = $tagAnalysisReport.DepartmentDistribution
            $datasets['ComplianceAnalysis'] = $tagAnalysisReport.ComplianceRequirements

            # Adicionar recomendações se existirem
            if ($IncludeRecommendations -and $recommendations.Count -gt 0) {
                $datasets['Recommendations'] = $recommendations
                $datasets['RecommendationsByPriority'] = $summary.RecommendationsByPriority
            }
        }
        catch {
            Write-Log "❌ Erro na fase 6: $($_.Exception.Message)" -Level Error
            Write-Log "🔍 Line: $($_.InvocationInfo.ScriptLineNumber)" -Level Debug
            throw
        }
        
        # Exportar dados conforme formato solicitado
        $timestamp = Get-Date -Format "yyyyMMdd-HHmmss"
        $exportSuccess = $false
        
        switch ($ExportFormat) {
            "CSV" {
                foreach ($datasetName in $datasets.Keys) {
                    $fileName = "FinOps_$($datasetName)_$timestamp.csv"
                    $filePath = Join-Path $OutputFolder $fileName
                    Export-ToCSV -Data $datasets[$datasetName] -FilePath $filePath | Out-Null
                }
                $exportSuccess = $true
            }
            "JSON" {
                $fileName = "FinOps_Complete_$timestamp.json"
                $filePath = Join-Path $OutputFolder $fileName
                $exportSuccess = Export-ToJSON -Data $datasets -FilePath $filePath
            }
            "Excel" {
                $fileName = "FinOps_Report_$timestamp.xlsx"
                $filePath = Join-Path $OutputFolder $fileName
                $exportSuccess = Export-ToExcel -DataSets $datasets -FilePath $filePath
            }
        }
        
        # Mostrar resultado final
        $duration = (Get-Date) - $startTime
        $durationStr = "{0:mm\:ss}" -f $duration
        
        Write-Log "`n🎉 ====== SIMULAÇÃO FINOPS CONCLUÍDA ======" -Level Info
        Write-Log "⏱️  Tempo de execução: $durationStr" -Level Info
        Write-Log "📊 Subscriptions processadas: $($subscriptions.Count)" -Level Info
        Write-Log "🏗️  Total de recursos: $($allResources.Count)" -Level Info
        Write-Log "💰 Registros de custo: $($costData.Count)" -Level Info
        Write-Log "📈 Pontos de métricas: $($metricsData.Count)" -Level Info
        Write-Log "🎯 Recomendações geradas: $($recommendations.Count)" -Level Info
        Write-Log "💾 Formato de exportação: $ExportFormat" -Level Info
        Write-Log "📂 Pasta de saída: $OutputFolder" -Level Info
        
        if ($exportSuccess) {
            Write-Log "✅ Dados exportados com sucesso!" -Level Info
        }
        else {
            Write-Log "⚠️  Problemas na exportação dos dados" -Level Warning
        }
        
        # Mostrar resumo financeiro
        $totalCost = $summary.Overview.TotalCost
        $potentialSaving = $summary.Overview.PotentialMonthlySaving
        
        Write-Log "`n💼 ====== RESUMO FINANCEIRO ======" -Level Info
        Write-Log "💰 Custo total simulado: R$ $($totalCost.ToString('N2'))" -Level Info
        if ($IncludeRecommendations -and $potentialSaving -gt 0) {
            Write-Log "💡 Economia potencial mensal: R$ $($potentialSaving.ToString('N2'))" -Level Info
            Write-Log "📊 Percentual de economia: $($summary.Overview.SavingPercentage)%" -Level Info
        }
        Write-Log "========================================`n" -Level Info
        
        return $true
    }
    catch {
        Write-Log "❌ Erro durante a execução: $($_.Exception.Message)" -Level Error
        Write-Log "🔍 Stack trace: $($_.ScriptStackTrace)" -Level Debug
        return $false
    }
}

#endregion

#region Script Entry Point

# Validar parâmetros
if ($MonthsBack -lt 1 -or $MonthsBack -gt 36) {
    Write-Log "❌ MonthsBack deve estar entre 1 e 36" -Level Error
    exit 1
}

if ($SimulationMode -and ($SubscriptionCount -lt 1 -or $SubscriptionCount -gt 100)) {
    Write-Log "❌ SubscriptionCount deve estar entre 1 e 100 no modo simulação" -Level Error
    exit 1
}

# Executar simulação
Write-Host "`n🌟 ====== SIMULADOR FINOPS AVANÇADO v4.0 ======" -ForegroundColor Magenta
Write-Host "🔧 Desenvolvido para análise de custos e otimização Azure" -ForegroundColor Cyan
Write-Host "================================================`n" -ForegroundColor Magenta

$success = Start-FinOpsSimulation -MonthsBack $MonthsBack -SimulationMode $SimulationMode -OutputFolder $OutputFolder -SubscriptionCount $SubscriptionCount -ResourceDensity $ResourceDensity -IncludeRecommendations $IncludeRecommendations -ExportFormat $ExportFormat -LogLevel $LogLevel

if ($success) {
    Write-Host "`n🎊 Simulação executada com sucesso!" -ForegroundColor Green
    Write-Host "📁 Verifique os arquivos gerados em: $OutputFolder" -ForegroundColor Yellow
    exit 0
}
else {
    Write-Host "`n❌ Falha na execução da simulação!" -ForegroundColor Red
    Write-Host "📋 Verifique os logs acima para detalhes" -ForegroundColor Yellow
    exit 1
}

#endregion

# Fim do script